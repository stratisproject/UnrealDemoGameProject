/**
 * NOTE: This class is auto generated by  Generator
 * https://github.com/Tools/-generator
 * Do not edit the class manually.
 */

#include "NFTApi.h"

#include "Log.h"
#include "NFTApiOperations.h"

#include "HttpModule.h"
#include "Serialization/JsonSerializer.h"

namespace stratis {
namespace nft {

NFTApi::NFTApi() {}

NFTApi::~NFTApi() {}

void NFTApi::AddHeaderParam(const FString &Key, const FString &Value) {
  AdditionalHeaderParams.Add(Key, Value);
}

void NFTApi::ClearHeaderParams() { AdditionalHeaderParams.Reset(); }

bool NFTApi::IsValid() const { return true; }

void NFTApi::SetHttpRetryManager(FHttpRetrySystem::FManager &InRetryManager) {
  if (RetryManager != &GetHttpRetryManager()) {
    DefaultRetryManager.Reset();
    RetryManager = &InRetryManager;
  }
}

FHttpRetrySystem::FManager &NFTApi::GetHttpRetryManager() {
  checkf(RetryManager,
         TEXT("NFTApi: RetryManager is null.  You may have meant to set it "
              "with SetHttpRetryManager first, or you may not be using a "
              "custom RetryManager at all.")) return *RetryManager;
}

FHttpRequestRef NFTApi::CreateHttpRequest(const Request &Request) const {
  if (!Request.GetRetryParams().IsSet()) {
    return FHttpModule::Get().CreateRequest();
  } else {
    if (!RetryManager) {
      // Create default retry manager if none was specified
      DefaultRetryManager = MakeUnique<HttpRetryManager>(6, 60);
      RetryManager = DefaultRetryManager.Get();
    }

    const HttpRetryParams &Params = Request.GetRetryParams().GetValue();
    return RetryManager->CreateRequest(
        Params.RetryLimitCountOverride,
        Params.RetryTimeoutRelativeSecondsOverride, Params.RetryResponseCodes,
        Params.RetryVerbs, Params.RetryDomains);
  }
}

void NFTApi::HandleResponse(FHttpResponsePtr HttpResponse, bool bSucceeded,
                            Response &InOutResponse) const {
  InOutResponse.SetHttpResponse(HttpResponse);
  InOutResponse.SetSuccessful(bSucceeded);

  if (bSucceeded && HttpResponse.IsValid()) {
    InOutResponse.SetHttpResponseCode(
        (EHttpResponseCodes::Type)HttpResponse->GetResponseCode());
    FString ContentType = HttpResponse->GetContentType();
    FString Content;

    if (ContentType.IsEmpty()) {
      return; // Nothing to parse
    } else if (ContentType.StartsWith(TEXT("application/json")) ||
               ContentType.StartsWith("text/json")) {
      Content = HttpResponse->GetContentAsString();

      TSharedPtr<FJsonValue> JsonValue;
      auto Reader = TJsonReaderFactory<>::Create(Content);

      if (FJsonSerializer::Deserialize(Reader, JsonValue) &&
          JsonValue.IsValid()) {
        if (InOutResponse.FromJson(JsonValue))
          return; // Successfully parsed
      }
    } else if (ContentType.StartsWith(TEXT("text/plain"))) {
      Content = HttpResponse->GetContentAsString();
      InOutResponse.SetResponseString(Content);
      return; // Successfully parsed
    }

    // Report the parse error but do not mark the request as unsuccessful. Data
    // could be partial or malformed, but the request succeeded.
    UE_LOG(LogNFT, Error,
           TEXT("Failed to deserialize Http response content (type:%s):\n%s"),
           *ContentType, *Content);
    return;
  }

  // By default, assume we failed to establish connection
  InOutResponse.SetHttpResponseCode(EHttpResponseCodes::RequestTimeout);
}

FHttpRequestPtr NFTApi::GetNFTInfo(
    const GetNFTInfoRequest &Request,
    const FGetNFTInfoDelegate &Delegate /*= FGetNFTInfoDelegate()*/) const {
  if (!IsValid())
    return nullptr;

  FHttpRequestRef HttpRequest = CreateHttpRequest(Request);
  HttpRequest->SetURL(*Request.ComputePath());

  for (const auto &It : AdditionalHeaderParams) {
    HttpRequest->SetHeader(It.Key, It.Value);
  }

  Request.SetupHttpRequest(HttpRequest);

  UE_LOG(LogNFT, Error, TEXT("URL: %s"), *(HttpRequest->GetURL()));
  HttpRequest->OnProcessRequestComplete().BindRaw(
      this, &NFTApi::OnGetNFTInfoResponse, Delegate);
  HttpRequest->ProcessRequest();
  return HttpRequest;
}

void NFTApi::OnGetNFTInfoResponse(FHttpRequestPtr HttpRequest,
                                  FHttpResponsePtr HttpResponse,
                                  bool bSucceeded,
                                  FGetNFTInfoDelegate Delegate) const {
  GetNFTInfoResponse Response;
  HandleResponse(HttpResponse, bSucceeded, Response);
  Delegate.ExecuteIfBound(Response);
}

} // namespace nft
} // namespace stratis
